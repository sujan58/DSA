import java.io.*;import java.util.*; public class Main {    static final class FastScanner {        private final InputStream in = System.in;        private final byte[] buffer = new byte[1 << 16];        private int ptr = 0;        private int buflen = 0;         private boolean hasNextByte() {            if (ptr < buflen) return true;            ptr = 0;            try {                buflen = in.read(buffer);            } catch (IOException e) {                e.printStackTrace();            }            return buflen > 0;        }         private int readByte() {            return hasNextByte() ? buffer[ptr++] : -1;        }         public boolean hasNext() {            while (hasNextByte() && buffer[ptr] <= 32) ptr++;            return hasNextByte();        }         public int nextInt() {            int c = readByte();            while (c <= 32) c = readByte();            boolean minus = false;            if (c == '-') {                minus = true;                c = readByte();            }            int res = 0;            while (c >= '0' && c <= '9') {                res = res * 10 + c - '0';                c = readByte();            }            return minus ? -res : res;        }    }     // Helper to calculate MEX of a list of numbers    // Returns an array where [0] is the MEX, and [1] is the NEXT MEX if the current MEX is added.    private static int[] getMexAndNextMex(List<Integer> arr) {        Collections.sort(arr);        int mex = 0;        for (int val : arr) {            if (val == mex) {                mex++;            } else if (val > mex) {                break;            }        }                // To find "next MEX", we pretend we added 'mex' to the array and continue searching        int nextMex = mex + 1;        for (int val : arr) {            if (val == nextMex) {                nextMex++;            } else if (val > nextMex && val > mex) {                 // Optimization: if val > nextMex, we can stop early,                 // but since the array is sorted, we just continue.                // We rely on the fact that we've already skipped all values < mex.                break;            }        }        return new int[]{mex, nextMex};    }     public static void main(String[] args) {        FastScanner scanner = new FastScanner();        StringBuilder out = new StringBuilder();         int t = scanner.nextInt();        while (t-- > 0) {            int n = scanner.nextInt();            List<List<Integer>> arrays = new ArrayList<>();            // Global frequency of every number across ALL arrays            Map<Integer, Integer> globalCounts = new HashMap<>();            long totalElements = 0;             // Frequencies within each specific array            List<Map<Integer, Integer>> localCounts = new ArrayList<>();             for (int i = 0; i < n; i++) {                int l = scanner.nextInt();                totalElements += l;                List<Integer> currentArray = new ArrayList<>();                Map<Integer, Integer> currentMap = new HashMap<>();                for (int j = 0; j < l; j++) {                    int val = scanner.nextInt();                    currentArray.add(val);                    globalCounts.put(val, globalCounts.getOrDefault(val, 0) + 1);                    currentMap.put(val, currentMap.getOrDefault(val, 0) + 1);                }                arrays.add(currentArray);                localCounts.add(currentMap);            }             long initialTotalMexSum = 0;            int[] initialMex = new int[n];            int[] nextMex = new int[n]; // What the MEX becomes if we add initialMex[i] to array i             for (int i = 0; i < n; i++) {                int[] m = getMexAndNextMex(arrays.get(i));                initialMex[i] = m[0];                nextMex[i] = m[1];                initialTotalMexSum += initialMex[i];            }             // The base answer is: (Initial Sum) * (Total Operations)            // Total operations = Total elements * (n - 1)            long totalOps = totalElements * (long)(n - 1);            long totalValue = initialTotalMexSum * totalOps;             // 1. Calculate Delta OUT (Removing elements)            for (int i = 0; i < n; i++) {                Map<Integer, Integer> counts = localCounts.get(i);                int myMex = initialMex[i];                                // We only care about removing values that are < myMex.                // If we remove a value >= myMex, the MEX doesn't change (it stays myMex).                // If we remove a value < myMex:                //   - If count > 1: MEX doesn't change.                //   - If count == 1: MEX drops to that value.                                for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {                    int val = entry.getKey();                    int count = entry.getValue();                     if (val < myMex && count == 1) {                        // Removing this specific 'val' causes MEX to drop from myMex to val.                        long loss = myMex - val;                        // This specific removal can happen towards any of the (n-1) other arrays.                        totalValue -= loss * (n - 1);                    }                }            }             // 2. Calculate Delta IN (Adding elements)            for (int k = 0; k < n; k++) {                int targetVal = initialMex[k]; // The only value that can increase MEX                                // How many instances of 'targetVal' exist in OTHER arrays?                int globalC = globalCounts.getOrDefault(targetVal, 0);                int localC = localCounts.get(k).getOrDefault(targetVal, 0);                                // FIX: Variable name cannot have spaces                long availableSources = globalC - localC;                 if (availableSources > 0) {                    // Each of these sources, if moved to array k, increases its MEX                    // from initialMex[k] to nextMex[k].                    long gain = nextMex[k] - initialMex[k];                    totalValue += gain * availableSources;                }            }             out.append(totalValue).append("\n");        }        System.out.print(out);    }}